#!/bin/bash
# Copyright 2015 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This script builds mali-drivers for a list of boards. It uploads the binaries
# to Google storage and makes them available in the public repository.

. "$(dirname "$0")/common.sh" || exit 1

DEFINE_boolean dryrun ${FLAGS_FALSE} \
  "dry run, don't upload anything and don't delete temporary dirs" n

# Parse command line.
FLAGS "$@" || exit 1
eval set -- "${FLAGS_ARGV}"

PN=mali-drivers
PNBIN=${PN}-bin

# Build board names.
BOARDS=(
  daisy
  daisy_freon
  peach_pit
  peach_pit-freon
  veyron_jerry
  veyron_jaq
)

# Suffixes for tarball name.
SUFFIXES=(
  daisy
  daisy-freon
  peach
  peach-freon
  veyron
  veyron-x11
)

# Board names for overlay with mali-drivers-bin.ebuild.
OBOARDS=(
  daisy
  daisy_freon
  peach
  peach_pit-freon
  veyron
  X11
)

# Overlay paths for each board.
OPATHS=(
  overlay-daisy
  overlay-variant-daisy-freon
  overlay-peach
  overlay-variant-peach-pit-freon
  overlay-veyron
  X11
)

# Script must run inside the chroot
restart_in_chroot_if_needed "$@"

create_run_script() {
  local script="$1"
  local outputtarball="$2"

  cat > "${script}" <<\__HDREOF__
#!/bin/sh
#
# Copyright 2015 The Chromium OS Authors. All rights reserved.
#
# Usage is subject to the enclosed license agreement.
# To be generated by Makeself 1.5.3
skip=@HDRSZ@
echo
echo The license for this software will now be displayed.
echo You must agree to this license before using this software.
echo

more << __EOF__
__HDREOF__

  cat "${SRC_ROOT}/third_party/chromiumos-overlay/licenses/Google-TOS" >> "${script}"
  echo __EOF__ >> "${script}"
  cat >> "${script}" <<\__BODYEOF__
if [ $? != 0 ]; then
  echo "ERROR: Couldn't display license file" 1>&2
  exit 1
fi

echo

printf 'Type "y" if you agree to the terms of the license: '
read typed

if [ "${typed}" != y ]; then
  echo
  echo "You didn't accept the license. Extraction aborted."
  exit 2
fi

echo

tail -n +${skip} "$0" | tar xjv 2>/dev/null

if [ $? -ne 0 ]; then
  echo
  echo "ERROR: Couldn't extract files." 1>&2
  exit 3
else
  echo
  echo "Files extracted successfully."
fi
exit 0
__BODYEOF__

  local hdrsize=$(wc -l < "${script}")

  sed -i "s/@HDRSZ@/$(( hdrsize + 1 ))/g" "${script}"

  cat "${outputtarball}" >> "${script}"

  chmod +x "${script}"
  du -b "${script}"
}

# arguments:
# $1 board name (Chrome OS board name to build)
# $2 binary package suffix (suffix added to tar package name)
# $3 overlay board name
# $4 overlay path

build_mali_board() {
  local board=$1
  local suffix=$2
  local oboard=$3
  local opath=$4
  echo "Board is ${board}"

  if [[ "$oboard" != "X11" ]]; then
    ./setup_board --board="${oboard}"
  fi
  ./setup_board --board="${board}"
  if [[ $? != 0 ]]; then
    die_notrace "Setting up board ${board} failed."
  fi

  # Make sure we are not building -9999 ebuild.
  # This could fail if cros_workon is already stopped so ignore return code.
  cros_workon --board="${board}" stop ${PN}

  if [[ "$oboard" == "X11" ]]; then
    echo "Building special X11 package"
    USE=X emerge-${board} ${PN}
  else
    emerge-${board} ${PN}
  fi

  if [[ $? != 0 ]]; then
    die_notrace "Emerging ${PN} for ${board} failed."
  fi

  local pv=$("equery-${board}" -q list -p -o --format="\$fullversion" ${PN} | sort | head -n 1)
  local category=$("equery-${board}" -q list -p -o --format="\$category" ${PN} | sort | head -n 1)
  local inputtarball="/build/${board}/packages/${category}/${PN}-${pv}.tbz2"
  local outputtarball="${PN}-${suffix}-${pv}.tbz2"
  local script="${PN}-${suffix}-${pv}.run"
  local gspath="gs://chromeos-localmirror/distfiles"

  echo "Current version is ${pv}"
  echo "Input tarball is ${inputtarball}"
  echo "Output tarball is ${outputtarball}"
  echo "Script is ${script}"

  local temp=`mktemp -d`
  echo "Temp dir is ${temp}"
  pushd "${temp}" >& /dev/null

  mkdir work
  if [[ $? != 0 ]]; then
    die_notrace "Couldn't create work directory."
  fi

  tar -C work -xpjvf "${inputtarball}"
  if [[ $? != 0 ]]; then
    die_notrace "Couldn't decompress package tarball ${inputtarball}."
  fi

  tar -C work --exclude=usr/lib/debug -cpjvf "${outputtarball}" ./
  if [[ $? != 0 ]]; then
    die_notrace "Couldn't create ${outputtarball}."
  fi

  create_run_script "${script}" "${outputtarball}"

  echo "Uploading tarball to ${gspath}/${script}"
  if [[ ${FLAGS_dryrun} -eq ${FLAGS_TRUE} ]]; then
    echo "Would run: gsutil cp -a public-read \"${script}\" \"${gspath}/${script}\""
  else
    gsutil cp -a public-read "${script}" "${gspath}/${script}"
    if [[ $? != 0 ]]; then
      die_notrace "Couldn't upload ${script} to ${gspath}/${script}."
    fi
    rm -rf "${temp}"
  fi

  if [[ "${oboard}" != "X11" ]]; then
    local pvbin=$("equery-${board}" -q list -p -o --format="\$fullversion" ${PNBIN} | sort | head -n 1)
    echo "Current version is ${pv} current binary version is ${pvbin}"
    # Uprev ebuild in git if it exists.
    if [[ -d "${SRC_ROOT}/overlays/${opath}/${category}/${PNBIN}" ]]; then
      cd "${SRC_ROOT}/overlays/${opath}/${category}/${PNBIN}"

      # following git commands may fail if they have been issued previously
      git checkout -b malidriverbinupdate m/master
      git mv "${PNBIN}-${pvbin}.ebuild" "${PNBIN}-${pv}.ebuild"

      "ebuild-${oboard}" "${PNBIN}-${pv}.ebuild" manifest
    fi
  fi

  popd >& /dev/null
}

main() {
  local idx
  local typed
  echo 'This script builds mali-drivers for a list of boards. It uploads the'
  echo 'binaries to Google storage and makes them available in the public'
  echo 'repository. It expects you have configured gsutil.'
  printf 'Type "y" if you know what you are doing and want to go ahead: '
  read typed

  if [[ "${typed}" != y ]]; then
    echo
    echo "Good choice."
    exit 2
  fi

  if [[ ! -f "${HOME}/.boto" ]]; then
    die_notrace "You did not configure gsutil after all."
  fi

  for (( idx = 0; idx < ${#BOARDS[@]}; ++idx )); do
    build_mali_board ${BOARDS[${idx}]} ${SUFFIXES[${idx}]} ${OBOARDS[${idx}]} ${OPATHS[${idx}]}
  done
}

main "$@"